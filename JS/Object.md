<!-- # method, 얕은 복사, 깊은 복사, 생성자 함수 -->

# Object

객체는 JavaScript라는 언어만이 가지고 있는 특징의 기초를 이루는 자료형으로 많은 기능을 내장하고 있습니다.

객체는 한꺼번에 여러 값을 담을 수 있는 통(container)과 같은 자료구조(data structure)입니다. `객체 안에는 이름-값 쌍(name-value pair)이 저장되는데, 이를 객체의 속성(property)이라고 합니다.`

객체는 `참조에 의해 할당되고 복사`됩니다. 변수엔 ‘객체’ 자체가 아닌 `메모리상의 주소`인 '참조’가 저장됩니다. 따라서 객체가 할당된 변수를 복사하거나 함수의 인자로 넘길 땐 객체가 아닌 객체의 참조가 복사됩니다.

그리고 복사된 참조를 이용한 모든 작업(프로퍼티 추가·삭제 등)은 동일한 객체를 대상으로 이뤄집니다.

객체의 '진짜 복사본’을 만들려면 '얕은 복사(shallow copy)'를 가능하게 해주는 Object.assign이나 '깊은 복사’를 가능하게 해주는 \_.cloneDeep(obj)를 사용하면 됩니다. 이때 얕은 복사본은 중첩 객체를 처리하지 못한다는 점을 기억해 두시기 바랍니다.

## 자바스크립트의 객체 생성 방법

객체 리터럴({})
Object 생성자 함수(new Object)
생성자 함수
Object.create 메서드
클래스(ES6)

## 메서드

프로퍼티 값이 함수인 경우 이것을 메서드라고 부른다.

## 점 표기법, 대괄호 표기법

아래와 같이 속성 접근자(property accessor)를 이용해 이미 생성된 객체의 속성을 지정해줄 수도 있습니다.

```js
const person = {}; // 빈 객체

// 점 표기법 (Dot notation)
person.name = '윤아준';
person.age = 19;
person.languages = ['Korean', 'English'];
```

JavaScript에서 `식별자로 허용되지 않는 문자가 들어간 속성 이름을 사용해야 하는 경우에는 반드시 대괄호 표기법을 사용`해야 합니다.

```js
// 대괄호 표기법 (Bracket notation)
person['한국 나이'] = 20;
```

위와 같은 경우가 아니라면, 주로 점 표기법이 많이 사용되는 편입니다.

## 전역 객체 (Global Object)

`JavaScript 구동 환경`은 전역 객체(Global Object)라는 특별한 객체를 갖고 있습니다. `전역 변수`가 선언되면, 이 변수는 또한 `전역 객체의 속성`이 되어 전역 객체를 통해서도 접근할 수 있게 됩니다.

전역 객체에는 구동 환경에서 유용하게 쓸 수 있는 속성과 함수가 미리 적재되어 있습니다. 예를 들어, 브라우저 환경에서는 서버와의 통신을 위한 ` fetch` 함수가 미리 적재되어 있습니다. Node.js 환경에서는, 모듈을 불러와 사용할 수 있도록 해 주는 `require` 함수가 미리 적재되어 있습니다.

## 참조 (Reference)

JavaScript에는 모두 일곱 가지의 타입이 존재합니다.

Boolean
Null6
Undefined
Number
String
Symbol
Object

이 중에 Object 타입, 그러니까 객체를 제외하고는 모두 원시 타입(primitive type)으로 불립니다. _객체는 참조 타입(reference type)으로 불립니다._

여기에서 *참조(reference)란, 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값*입니다. JavaScript에서는 우리가 참조를 직접 읽거나 조작할 수 없습니다. 하지만, 언어를 제대로 이해하기 위해서 참조가 무엇인지 알아야 할 필요는 있습니다.

_우리가 객체라고 생각하고 다루어왔던 값은 실제로는 객체에 대한 참조입니다._

```js
const obj = {}; // 변수 `obj`에는 객체에 대한 참조가 저장되었습니다.
```

객체의 속성에 접근하면, JavaScript 엔진은 참조를 통해 메모리에 저장되어 있는 객체에 접근해서 해당 객체의 속성을 읽습니다. 이런 동작을 가지고 역참조(dereference)라고 합니다.

```js
const obj = { prop: 1 };
obj.prop; // `obj`를 통해 역참조된 객체의 속성을 읽어왔습니다.
```

## 함수 호출

앞에서, **함수 호출 시에는 인수가 복사되어 매개변수에 대입**된다고 설명했습니다. 만약 함수 호출 시에 객체를 인수로 넘긴다면, 이 때 역시 실제로 복사되는 것은 *객체 자체가 아니라 참조*입니다. 그래서, 우리는 이 참조를 이용해 원본 객체의 내용을 변경할 수 있습니다. 원본이나, 복사된 참조나 같은 객체를 가리키기 때문입니다.

```js
const obj = {};

function addProp(o) {
	o.prop = 1;
}

// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.
addProp(obj);

console.log(obj.prop); // 1
```

## 객체의 같음 (Equality)

우리는 이제까지 === 연산자를 이용해서 두 값이 같은지를 판별해 왔습니다. 그런데 객체에 대해서는 비교 연산 역시 오묘하게 동작합니다. 내용이 같은 두 객체를 === 연산자를 통해 비교해도, 결과값은 false로 나옵니다.

```js
{prop: 1} === {prop: 1}; // false
[1, 2, 3] === [1, 2, 3]; // false
```

위의 *등호 연산자 역시, 객체의 내용을 비교하는 것이 아니라 객체의 참조를 비교*합니다. _우리가 생성자나 리터럴을 이용해 객체를 생성하면, 객체는 매 번 새로 생성되어 각각 메모리의 다른 위치에 저장됩니다._ 그래서, 내용이 똑같아 보이는 두 객체일지라도 그에 대한 참조는 서로 다른 것입니다.

당연하게도, 두 참조가 정말로 같은 객체를 가리키고 있다면 등호 연산자는 true를 반환합니다.

```js
const obj1 = {};
const obj2 = obj1;
obj1 === obj2; // true
```

프로그램을 작성하다가 객체에 대한 비교를 하는 코드를 짜고 있는 자신을 발견하게 되면, 지금 객체의 내용을 비교하려고 하는 것인지, 또는 객체의 참조를 비교하려고 하는 것인지를 꼭 생각해보세요. 객체의 내용을 통해 비교하고 싶다면, 깊은 비교 기능을 지원하는 라이브러리를 이용하거나, 정확히 어떤 내용을 비교하고 싶은지를 가지고 함수 혹은 메소드를 작성한 후 그것을 이용하세요.

## 래퍼 객체 (Wrapper Object)

원시 타입의 값은 객체가 아님에도 불구하고, 원시 타입에 점 표기법을 써서 메소드를 호출하거나 속성을 읽어올 수 있는데, 이는 *JavaScript가 래퍼 객체(wrapper object)라는 기능을 제공*하기 때문입니다.

**원시 타입의 값에 대해 속성을 읽으려고 시도하면, 그 값은 그 순간에만 객체로 변환되어 마치 객체인 것처럼 동작합니다.**

```js
const s = 'hello';
s.toUpperCase(); // 'HELLO'
s.length; // 5

const n = 1.2345;
n.toFixed(2); // '1.23'

const b = true;
b.toString(); // 'true'
```

아래는 래퍼 객체를 생성시키기 위해 사용되는 생성자들의 목록입니다.

String
Number
Boolean
Symbol

위 생성자들을 이용해 우리가 직접 객체를 생성할 수도 있습니다. 하지만 직접 객체를 생성해주지 않아도 원시 타입의 값에 대해 메소드를 호출하거나 속성을 읽을 수 있기 때문에, 직접 객체를 생성해줄 일은 잘 없습니다.

## 메소드 (Method)

객체의 속성값으로 함수를 지정할 수도 있습니다.

```js
const person = {
	greet() {
		return 'hello';
	},
};

person.greet(); // 'hello';
```

위와 같이 **어떤 객체의 속성으로 접근해서 사용하는 함수를 메소드(method)**라고 부릅니다.

## this

다른 함수들과 달리 '메소드'라는 특별한 이름을 사용하는 이유는, *메소드가 다른 함수들과는 다르게 특별히 취급되기 때문*입니다. **this 키워드**를 사용하면, **메소드 호출 시에 해당 메소드를 갖고 있는 객체에 접근**할 수 있습니다.

_메소드를 사용하면, 데이터와, 그 데이터와 관련된 동작을 객체라는 하나의 단위로 묶어서 다룰 수 있습니다._ 이것이 함수 대신 메소드를 사용하는 핵심적인 이유입니다.

여기서 주의할 점이 있습니다. function 키워드를 통해 정의된 함수 내부의 this 키워드가 실제로 무엇을 가리킬 것인가는, *메소드가 어떻게 정의되는가에 의해 결정되는 것이 아니라 메소드가 어떻게 사용되는가*에 의해 결정됩니다.

같은 함수임에도 불구하고 *어떤 객체의 메소드로 사용되느냐*에 따라 메소드 내부의 this가 가리키는 객체가 달라질 수 있다는 것입니다.

다만, **화살표 함수는 this 키워드를 전혀 다르게 취급**하기 때문에 위와 같은 방식으로는 메소드로 사용될 수 없습니다. 또한, function 키워드를 통해 정의된 메소드가 항상 위와 같은 방식으로 this를 취급하는 것은 아닙니다. 특별한 방법을 통해 아예 this를 우리가 원하는 객체로 바꿔버릴 수도 있습니다.

```js
const person = {
	name: '윤아준',
	age: 19,
	introduce() {
		// `this`를 사용해서 객체의 속성에 접근함
		return `안녕하세요, 제 이름은 ${this.name}입니다. 제 나이는 ${this.age}살 입니다.`;
	},
	getOlder() {
		// `this`를 사용해서 객체의 속성을 갱신함
		this.age++;
	},
};

person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 19살 입니다.'
person.getOlder(); // undefined
person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 20살 입니다.'
```

```js
function introduce() {
	return `안녕하세요, 제 이름은 ${this.name}입니다.`;
}

const person1 = {
	name: '윤아준',
	introduce,
};

const person2 = {
	name: '신하경',
	introduce,
};

person1.introduce(); // 안녕하세요, 제 이름은 운아준입니다.
person2.introduce(); // 안녕하세요, 제 이름은 신하경입니다.
```

이렇게 introduce라는 함수가 객체 외부에서 정의되었고, person1과 person2에서 재사용되었는데도 불구하고 메소드가 잘 동작했습니다. 즉, *같은 함수임에도 불구하고 어떤 객체의 메소드로 사용되느냐에 따라 메소드 내부의 this가 가리키는 객체가 달라질 수 있다는 것*입니다.

다만, *화살표 함수*는 _this_ 키워드를 전혀 다르게 취급하기 때문에 위와 같은 방식으로는 메소드로 사용될 수 없습니다. 또한, function 키워드를 통해 정의된 메소드가 항상 위와 같은 방식으로 this를 취급하는 것은 아닙니다. 특별한 방법을 통해 아예 this를 우리가 원하는 객체로 바꿔버릴 수도 있습니다.

## 얕은 복사(Shallow Copy) & 깊은 복사(Deep Copy)

프로그래밍 분야에서는 *중첩된 자료구조까지 모두 복사하는 것을 가지고 깊은 복사(deep copy)*라고 합니다. JavaScript에는 깊은 복사를 위한 기능이 내장되어 있기 않기 때문에, 직접 구현을 해서 사용해야 합니다. 그런데 깊을 복사를 할 때 고려해야 할 것들이 많아서 (순환참조, 프로토타입, 열거 불가능한 속성, getter/setter 등) 정말로 직접 구현하기는 어렵고, 관련 라이브러리를 사용하는 것을 추천합니다.

비슷한 객체의 복제가 빈번하게 이루어져야 하는 경우에는 Immutable.js와 같은 라이브러리의 사용도 고려해 보시길 바랍니다.
