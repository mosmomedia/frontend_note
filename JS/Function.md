# Function

프로그래밍에서의 함수란, *큰 프로그램을 잘게 쪼개어 특정 코드 뭉치를 반복해서 사용할 수 있도록 묶어놓은 코드 뭉치의 단위*를 말합니다. 함수를 어떻게 작성하느냐에 따라서 코드의 유지보수성과 가독성이 크게 달라집니다.

컴퓨터 과학 분야에서 사용되는 용어 중에 *1급 시민(First-Class Citizen)*이라는 특이한 용어가 있습니다. 값으로 사용할 수 있는 JavaScript의 함수는 1급 시민입니다. 1급 시민인 함수를 줄여서 1급 함수라 부르기도 합니다.

## 객체로서의 함수

*함수는 Function 생성자로부터 생성되는 객체*입니다. 다만, 다른 객체들과는 다르게 호출할 수 있다(callable)는 특징이 있습니다.

함수 객체는 두 가지 유용한 속성을 갖고 있습니다.

length - 함수의 매개변수의 개수를 반환합니다.
name - 함수의 이름을 반환합니다.

## 매개변수와 인수

매개변수는 *변수의 일종*으로, 함수 호출 시마다 인수가 매개변수에 대입됩니다.

여기서 주의할 점은 *매개변수는 바깥에서 선언된 변수와는 관계없는 독립적인 변수*라는 것입니다. 예를 들어, 함수 호출 시 인수가 들어갈 자리에 변수를 써주고, 함수 내부에서 매개변수에 새로운 값을 대입한다고 하더라도 인수로 써준 변수의 값이 변경되지 않습니다.

## 스코프

이렇게, 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있습니다. 즉, *변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있는 것입니다. 이렇게, 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)*라고 합니다.

매개변수는 특정 함수의 내부 코드 안에서만 접근할 수 있습니다. 즉, *매개변수는 함수 스코프*를 갖습니다.

## 변수 가리기 (Variable Shadowing)

단일 스코프에서는 같은 이름을 갖는 서로 다른 변수가 존재할 수 없습니다. 하지만 *스코프 연쇄*가 일어나면 이야기가 달라집니다. 아래의 코드에서는 x라는 이름을 갖는 변수가 세 번 정의되었습니다.

```js
const x = 3;
function add5(x) {
	// `x`라는 변수가 다시 정의됨
	function add(x, y) {
		// `x`라는 변수가 다시 정의됨
		return x + y;
	}
	return add(x, 5);
}
add5(x);
```

위와 같이, *바깥쪽 스코프에 존재하는 변수와 같은 이름을 같는 변수를 안쪽 스코프에서 재정의*할 수 있습니다. 그렇게 되면 안쪽 스코프에서는 바깥쪽 스코프에 있는 이름이 무시됩니다. 이런 현상을 *변수 가리기(variable shadowing)*라고 합니다.

## 어휘적 스코핑 (Lexical Scoping)

_스코프는 코드가 작성된 구조에 의해서 결정되는 것이지, 함수 호출의 형태에 의해 결정되는 것이 아닙니다_. 예를 들어 봅시다.

```js
function add5(x) {
	const five = 5;
	return add(x);
}

add5(3); // 8

function add(x) {
	return five + x; // ReferenceError: five is not defined
}
```

add라는 함수가 add5라는 함수 안에서 호출되었다고 해서, add 함수 내부에서 add5 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아닙니다. 스코프는 코드가 작성된 구조에 의해 결정되는 성질입니다. 위 코드를 동작시키려면, 아래와 같이 작성해야 합니다.

```js
function add5(x) {
	const five = 5;
	function add(x) {
		return five + x;
	}
	return add(x);
}
```

## 익명 함수 (Anonymous Function)

_익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할 때 많이 사용됩니다_. 대표적인 경우는 *함수를 인수*로 넘겨줄 때입니다. 예를 들어, 배열의 filter 메소드에 필터링할 조건을 표현하는 함수를 넘겨주면, filter
메소드쪽에서 배열 각 요소에 대해 함수를 호출한 뒤, true를 반환한 요소만을 필터링해서 반환합니다.

## 화살표 함수 (Arrow Function)

함수 정의를 위한 새로운 표기법인 화살표 함수(arrow function)은 ES2015에서 도입되었습니다.

```js
// 여기에서 x + y 는 **바로 반환됩니다.**
const add = (x, y) => x + y;
```

바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces({...}) 로 둘러싸주어야 합니다.
_`=>` 다음 부분을 중괄호로 둘러싸면, 명시적으로 `return` 하지 않는 한 아무것도 반환되지 않습니다._

```js
const add = (x, y) => {
	const result = x + y;
	return result;
};
```

매개변수가 하나밖에 없다면, 매개변수 부분의 괄호를 쓰지 않아도 무방합니다.

```js
const negate = (x) => !x;
```

화살표 함수는 표기법이 간단하기 때문에 _익명 함수를 다른 함수의 인수로 넘길 때 주로 사용됩니다._

```js
[1, 2, 3, 4, 5].filter((x) => x % 2 === 0);
```

_화살표 함수의 특징_

1. 화살표 함수는 생성자로 사용될 수 없습니다. 따라서 prototype 속성을 갖고 있지 않습니다. 그리고 스스로의 new.target을 가지지 않습니다.

2. 화살표 함수는 스스로의 this, arguments, super를 가지지 않습니다.

3. 화살표 함수 내부에서 yield 키워드를 사용할 수 없습니다. 즉, 제너레이터로 사용될 수 없습니다.

여기서 스스로의 this를 가지지 않는다는 말은 함수 내부에서 this를 사용할 수 없다는 말이 아닙니다. _화살표 함수 내부에서 this를 사용하면, 그 this는 함수가 정의된 스코프에 존재하는 this를 가리킵니다._ 이는 new.target, arguments, super 모두 마찬가지입니다.

```js
function Person(name) {
	this.name = name;
	this.getName = () => {
		// 여기에서 사용된 `this`는 '함수가 정의된 스코프', 즉 'Person 함수 스코프'에 존재하는 `this`를 가리키게 됩니다.
		return this.name;
	};
}

const mary = new Person('mary');
mary.getName(); // 'mary'
```

이런 성질 때문에, 화살표 함수 내부에 있는 this는 엄격 모드의 영향을 받지 않습니다.

_화살표 함수는 스스로의 this를 갖지 않는다고 했습니다. 이 때문에, 화살표 함수에 대해 bind, call, apply 메소드를 호출해도 아무런 효과가 없습니다._

그리고, 화살표 함수 내부에서 this를 사용하면 함수가 정의된 스코프에 있는 this를 가리킨다고 했습니다. **즉, 화살표 함수 내부의 this는 화살표 함수가 정의된 문맥에 의해 결정됩니다. function 구문으로 정의된 함수에서 쓰이는 this가 어떻게 호출되는지에 의해 결정되는 것과는 다른 동작 방식을 보입니다.**

```js
const mary = {
	name: 'mary',
	getName: () => {
		return this.name;
	},
};

// 위의 화살표 함수는 전역 스코프에서 정의되었기 때문에, `this`는 전역 객체를 가리킵니다.
// `mary`의 메소드로 사용된다고 해도, 이 사실이 변하지 않습니다.
// 브라우저 환경의 전역 객체인 `window`는 `name`이라는 속성에 빈 문자열을 갖고 있기 때문에, 이 값이 대신 반환됩니다.
mary.getName(); // ''
```

**이처럼, 객체의 속성 값에 메소드를 직접 정의할 때에는 화살표 함수를 사용해서는 안 됩니다.**

그러면 어떨 때 화살표 함수를 사용하는 게 좋을까요? _화살표 함수의 편리함은 함수를 다른 함수의 인수로 넘겨야 할 때 발휘됩니다._ 함수를 받아서 호출하는 쪽에서 어떻게 호출하든, this 때문에 문제가 생길 일이 없습니다. *화살표 함수의 this는 '어떻게 정의되었는지'에 따라 결정*되기 때문이죠!

아래 코드를 실행해보시고, getName 메소드를 일반적인 함수(function () { ...)로 바꾸어서 결과가 어떻게 나오는지 관찰해보세요.

```js
function Person(name) {
	this.name = name;
	this.getName = () => {
		return this.name;
	};
}

const mary = new Person('mary');

function printResult(func) {
	console.log(func());
}

// 화살표 함수로 정의된 메소드는 다른 함수의 인수로 넘겨도 아무런 문제가 없습니다!
printResult(mary.getName);
```

정리하겠습니다. function 구문으로 생성되는 함수가 단순한 함수 이외에 생성자나 제너레이터 등의 여러 기능까지 떠맡고 있는 반면에, _화살표 함수는 오직 함수 혹은 메소드로 사용되도록 만들어졌습니다._ 그리고 어떻게 호출되더라도 this가 변하지 않고 문법이 간결하기 때문에, _함수를 값으로 다루어야 하는 경우 (특히 함수를 다른 함수의 인수로 넘겨야 하는 경우) 에는 화살표 함수가 일반 함수보다 편리한 경우가 많습니다._

## 주인 없는 this

*this는 생성자 혹은 메소드에서 객체를 가리킬 때 사용하는 키워드*입니다. 하지만, 생성자나 메소드가 아닌 함수에서 this 키워드를 사용한다고 해서 에러가 나지는 않습니다

```js
function printThis() {
	console.log(this);
}

printThis(); // Window { ... }

// 위 예제에서 this는 전역 객체를 가리키고 있습니다!
```

예전 버전(ES5 미만)의 JavaScript에는 여러 가지 좋지 않은 부분들이 있는데, *this가 전역 객체를 가리키는 성질은 이들 중 가장 대표적인 것*입니다. 이런 이상한 동작 방식 때문에, 프로그래머의 작은 실수로 인해 큰 문제가 생길 수도 있습니다.

## this 바꿔치기

앞에서 봤던 것처럼, this는 때에 따라 다른 값을 가리킵니다. 심지어는 우리가 원하는 값을 가리키게 만들 수도 있는데, 함수 객체의 _bind, call, apply_ 메소드를 사용하면 됩니다.

_함수 객체의 bind 메소드를 호출하면, 메소드의 인수로 넘겨준 값이 this가 되는 새로운 함수를 반환합니다._

```js
function printGrade(grade) {
	console.log(`${this.name} 님의 점수는 ${grade}점입니다.`);
}

const student = { name: 'Mary' };
const printGradeForMary = printGrade.bind(student);
printGradeForMary(100); // Mary 님의 점수는 100점입니다.
```

call 혹은 apply 메소드를 사용하면, _새로운 함수를 만들지 않고도 임시적으로 this를 바꿔버릴 수 있습니다_. call과 apply는 인수를 넘겨주는 형식에 차이가 있을 뿐, 나머지 기능은 동일합니다.

```js
function printGrade(grade) {
	console.log(`${this.name} 님의 점수는 ${grade}점입니다.`);
}

const student = { name: 'Mary' };

printGrade.call(student, 100); // Mary 님의 점수는 100점입니다.
printGrade.apply(student, [100]); // Mary 님의 점수는 100점입니다.
```

## 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)
