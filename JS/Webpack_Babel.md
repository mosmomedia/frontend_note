# Webpack

웹팩이란 최신 프런트엔드 프레임워크에서 가장 많이 사용되는 `모듈 번들러(Module Bundler)`입니다. 모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미합니다.

_웹팩에서의 모듈_

웹팩에서 지칭하는 모듈이라는 개념은 위와 같이 자바스크립트 모듈에만 국한되지 않고 웹 애플리케이션을 구성하는 모든 자원을 의미합니다. 웹 애플리케이션을 제작하려면 HTML, CSS, Javascript, Images, Font 등 많은 파일들이 필요하죠. 이 파일 하나하나가 모두 모듈입니다.

_모듈 번들링이란?_
웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 `하나의 파일로 병합 및 압축 해주는 동작을 모듈 번들링`이라고 합니다.

_웹팩의 등장 배경_

1. 파일 단위의 자바스크립트 모듈 관리의 필요성
2. 웹 개발 작업 자동화 도구 (Web Task Manager)
3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능

_웹팩으로 해결하려는 문제?_

1. 자바스크립트 변수 유효 범위
2. 브라우저별 HTTP 요청 숫자의 제약
3. 사용하지 않는 코드의 관리
4. Dynamic Loading & Lazy Loading 미지원

### 다양한 모듈 스펙

이러한 방식으로 자바스크립트 모듈을 구현하는 대표적인 명세가 `AMD와 CommonJS`다.

**CommonJS** 는 자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표다
exports 키워드로 모듈을 만들고 `require()` 함수로 불러 들이는 방식이다.
대표적으로 서버 사이드 플래폼인 `Node.js`에서 이를 사용한다.

```js
math.js:

exports function sum(a, b) { return a + b; }

app.js:

const math = require("./math.js")
math.sum(1, 2) // 3
```

**AMD(Asynchronous Module Definition)**는 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 목표다.
주로 `브라우져 환경`이다.

**UMD(Universal Module Definition)**는 AMD기반으로 CommonJS 방식까지 지원하는 통합 형태다.

이렇게 각 커뮤니티에서 각자의 스펙을 제안하다가 ES2015에서 표준 모듈 시스템 을 내 놓았다. 지금은 `바벨과 웹팩을 이용해 모듈 시스템을 사용하는 것이 일반적`이다.

ES2015 모듈 시스템의 모습을 살펴보자.

```js
math.js:

export function sum(a, b) {
return a + b
}

app.js:

import \* as math from "./math.js"
math.sum(1, 2) // 3
```

export 구문으로 모듈을 만들고 import 구문으로 가져올 수 있다.

### 브라우져의 모듈 지원

```js
index.html:
<script type="module" src="app.js"></script>
```

script 태그로 로딩할 때 type="text/javascript" 대신 type="module"을 사용한다.

app.js는 모듈을 사용할 수 있다.
그러나 **브라우져에 무관하게 모듈을 사용하고 싶은데...... 이제야 웹팩이 나올 차례다.**

_Links_
https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html

<!--  -->

요즘 웹팩이 매우 핫하지만 사람들은 웹팩에 대해 매우 어려워합니다. 저도 어려웠습니다. 왜냐면 공식 문서가 친절하지 않거든요(지금 이것도 매우 친절해진 겁니다). 그리고 모든 파일을 하나로 합친다는 개념도 잘 와닿지 않습니다. 왜 파일을 하나로 합쳐야 할까요? 바로 http 요청이 비효율적이기 때문입니다.

웹 페이지는 수 많은 구성요소로 이루어져 있습니다. 기본적인 html, js, css 파일 외에도, 웹폰트, favicon, 이미지, json 데이터 등등 수 많은 파일들을 받아와야 합니다. 다행히 http/2에서는 하나의 커넥션에 동시에 여러 파일들을 요청할 수 있습니다. http/2가 점점 더 보편화되어가고 있지만 여전히 파일 개수가 적어야 좋은 경우도 많습니다. 심지어 http/2를 못 쓴다면 http/1.1에서는 커넥션 하나를 열어 하나씩 요청을 보내야합니다. 하나의 요청이 끝나야 다음 요청을 보낼 수 있기 때문에 요청이 많을수록 비효율적이죠. (물론 브라우저에서 파이프라이닝이라는 꼼수로 요청을 여러 개씩 보내기는 하는데 그것도 동시에 6개 정도 뿐이고, 근본적인 해결 방법은 아닙니다)

http/2는 아직은 무리고(망할 IE에서 지원하지 않습니다) http/1은 너무 느리다면 어떻게 해야 할까요? 네... 방법이 없습니다. 개발자인 저희가 희생해야죠. 바로 요청 수를 줄이는 겁니다! 그래서 이미지는 스프라이트로 만들어 한 번에 받고, 걸프, 그런트같은 번들러로 js파일이나 css파일을 하나로 합치곤 했죠. 그러다가 이제 번들러 끝판왕 웹팩이 나왔습니다. 하나로 합쳐주면서 크로스 브라우징 대응도 해주고 압축도 해주는 등 여러모로 편한 점이 많습니다. 아래의 그림처럼 여러 파일들을 하나로 합쳐줍니다.

# Babel

바벨 공식문서에서는 바벨을 `자바스크립트 컴파일러`라고 소개하며 최신 자바스크립트 문법을 사용할 수 있다고 나와있다. 더 정확하게 말하면 트랜스파일러라고 말할 수 있다. (트랜스파일러는 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 언어로 변환하는 것을 말하며 컴파일러의 일종이다) 그렇다면 왜 바벨이 필요하고 바벨이 있어야만 자바스크립트의 최신 문법을 사용할 수 있을까?

그 이유는 자바스크립트가 실행되는 환경때문이다. `다른 언어와 달리 자바스크립트는 정말 많은 환경에서 실행`된다. 웹 브라우저, NodeJS, Deno 등에서 실행되는데 웹 브라우저 또한 각자 다른 자바스크립트 엔진을 통해 자바스크립트 코드를 읽게 된다. 게다가 이렇게 실행되는 환경의 버전에도 자바스크립트는 영향을 받는다. `특정 버전 이상에서만 실행되는 코드가 있고 특정 브라우저에서는 실행되지 않는 코드도 있다.` 그렇기 때문에 `모든 자바스크립트 실행 환경에서 정상적으로 동작`할 수 있도록 하려면 바벨이 필요하다.

<!--  -->

위에서 발생한 예외를 근본적으로 해결하려면 우리가 작성한 코드를 NodeJS 런타임이 실행가능한 형태로 변환해줘야 합니다. 이를 보통 transpile이라고 하는데요. 소스 코드를 머신 코드로 바꿔주는 compile과 달리, transpile은 같은 언어를 유지한체 다른 런타임에서 해당 코드가 정상적으로 해석될 수 있도록 형태만 바꿔준다는 차이가 있습니다. 실제 현장에서는 이 두 용어를 혼용해서 사용하고 있는 것 같습니다.

여기서는 JavaScript Transpiler 중에서 가장 널리 사용되는 Babel을 사용해서 위 코드를 transpile하여 NodeJS 런타임이 예외없이 실행할 수 있도록 해보겠습니다.
