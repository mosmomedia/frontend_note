# Prototype

JavaScript에서는 이렇게 *객체 간에 공유되어야 하는 속성과 메소드를, 프로토타입(prototype)이라는 기능을 이용해서 효율적으로 저장*할 수 있습니다. 어떤 객체에 프로토타입을 지정하면, 프로토타입의 속성을 해당 객체에서 재사용할 수 있습니다. 객체의 프로토타입을 지정하는 방법에는 여러 가지가 있는데, 가장 쉬운 방법은 _Object.create_ 함수를 이용하는 것입니다.

JavaScript 객체의 속성에 접근하면, *JavaScript 엔진은 child 객체의 속성만 확인하는 것이 아니라 프로토타입 객체의 속성까지 확인*합니다. 그래서 프로토타입에 해당 이름을 갖는 속성이 있다면 그 속성의 값을 반환합니다.

만약에 프로토타입 객체에도 해당 이름의 속성이 없으면 어떻게 될까요? 여기서 짚고 넘어가야 할 것은 프로토타입 객체도 객체라는 것입니다. 즉, 프로토타입 객체의 프로토타입 객체가 있을 수 있다는 말이죠. 이렇게 계속 이어져 있는 프로토타입의 연쇄를 *프로토타입 체인(prototype chain)*이라 부릅니다.

즉, JavaScript 엔진은 속성 접근자를 통해 어떤 객체의 속성을 확인할 때 프로토타입 체인을 전부 확인합니다.

프로토타입 체인은 눈에 명확히 보이지는 않지만, 객체의 속성에 접근할 때마다 탐색됩니다. 따라서 *프로토타입 체인의 깊이가 너무 깊으면 속성의 읽기 속도에 영향을 미치므로 주의*해야 합니다.

프로토타입 체인을 따라가다 보면 언젠가는 *null*을 만난다는 결론에 도달하게 됩니다. 프로토타입을 명시적으로 null로 지정하지 않아도, 언젠가는 Object.prototype, 즉 프로토타입이 null인 객체를 만나게 됩니다. 이 때에 프로토타입 체인을 확인하는 과정이 끝나는 것입니다.

_어떤 객체의 속성을 변경하거나 속성을 삭제하는 작업은 그 객체의 프로토타입에 아무런 영향을 미치지 않습니다._

## 속성 가리기 (Property Shadowing)

만약 프로토타입 체인에서 같은 이름의 속성이 여러 번 등장하면 어떤 일이 일어날까요?
프로토타입 체인의 상위에 있는 속성이 하위 속성에 의해 가려지는 현상을 *속성 가리기(property shadowing)*라고 합니다.

## 생성자 (Constructor)

이제까지는 객체를 생성하기 위해 _객체 리터럴_ 또는 _Object.create_ 함수를 사용했습니다. 하지만 이것 말고도 한 가지 방법이 더 있는데, 바로 *new 키워드*를 이용하는 것입니다.

*Object*는 함수입니다! 이렇게 객체를 만들 때 _new_ 키워드와 함께 사용하는 *함수*를 가지고 *생성자(constructor)*라고 부릅니다.

**생성자 정의하기**

JavaScript에서는 Object 뿐만 아니라, 내장된 많은 생성자들이 있고, 심지어 프로그래머가 직접 생성자를 만들 수도 있습니다. 여기서 this 키워드가 한 번 더 등장합니다.

```js
// 생성자 정의
function Person(name) {
	this.name = name;
}

// 생성자를 통한 객체 생성
const person1 = new Person('윤아준');
```

위에서 function 구문을 통해 Person이라는 생성자를 정의하고, 생성자 안에서는 this 키워드를 사용해서 새로 만들어질 객체의 속성을 지정해 주었습니다. new 키워드를 사용해서 객체를 생성하는 순간에 생성자 안에 있는 코드가 실행되어 객체의 속성이 지정되는 것입니다.

**인스턴스 (Instance)**

생성자를 통해 생성된 객체를 그 생성자의 인스턴스(instance)라고 합니다. 위의 예제에서는 person1이 Person의 인스턴스입니다. _instanceof_ 연산자를 사용하면, 객체가 특정 생성자의 인스턴스가 맞는지를 확인할 수 있습니다.

**생성자와 프로토타입**

_생성자를 통해 만들어낸 객체의 프로토타입에는 생성자의 prototype 속성에 저장되어 있는 객체가 자동으로 지정됩니다._

그리고, JavaScript에서는 function 구문을 통해 함수를 정의할 때 함수의 prototype 속성에 객체가 자동으로 생성되어 저장됩니다.

```js
// 사람을 나타내는 객체를 생성하는 팩토리 함수
function Person(name) {
	this.name = name;
}
Person.prototype.introduce = function () {
	return `안녕하세요, 제 이름은 ${this.name}입니다.`;
};

const person = new Person('윤아준');

person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다.'
```

*생성자의 속성에 직접 지정된 메소드를 정적 메소드(static method)*라고 합니다. 우리가 이제까지 유용하게 사용했던 Number.isNaN, Object.getPropertyOf 등의 함수들은 모두 정적 메소드입니다. 정적 메소드는 특정 인스턴스에 대한 작업이 아니라, *해당 생성자와 관련된 일반적인 작업을 정의*하고 싶을 때 사용됩니다.

## Class

클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다. 호이스팅은 var, let, const, function, function\* , class 키워드를 사용한 모든 선언문에 적용된다. 다시 말해, 선언문을 통해 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.
