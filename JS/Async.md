# 비동기 프로그래밍 (Asyncronous Programming)

이처럼 어떤 일이 완료되기를 기다리지 않고 다음 코드를 실행해 나가는 프로그래밍 방식을 일러 **비동기 프로그래밍(asynchronous programming)** 이라고 합니다. 반대로 어떤 일이 완료될 때까지 코드의 실행을 멈추고 기다리는 프로그래밍 방식을 동기식 프로그래밍(synchronous programming)이라고 부릅니다.

브라우저에서의 비동기 프로그래밍은 주로 통신과 같이 오래 걸리는 작업들을 브라우저에 위임할 때 이루어집니다.

_비동기적으로 처리해야할 작업들_

1. 파일을 읽거나, 쓰기 처럼 오래걸리는 작업
2. ajax 통신작업
3. Dom의 이벤트 처리작업
4. 일정 시간 뒤에 동작을 해야 하는 작업

비동기 프로그래밍 방식은 대개 프로그램의 성능과 응답성을 높이는 데에 도움을 줍니다. 하지만 코드가 실제로 실행되는 순서가 뒤죽박죽이 되므로, 코드의 가독성을 해치고 디버깅을 어렵게 만든다는 비판을 받아왔습니다. 이런 문제를 해결하기 위해 비동기 프로그래밍을 위한 여러 기법이 생겨났고, 또 어떤 것들은 JavaScript 언어 자체에
포함되기도 했습니다.

자바스크립트는 브라우저 위에서 사용하는 언어이다. 자바스크립트는 기본적으로 통신이라는 개념을 가지고 있고 통신 중 어떤 함수가 일 처리가 길어지면, 웹 브라우저는 계속 멈춤 상태가 되고 기다려야 된다. 이 상황을 방지하기 위해 비동기 방식을 가지게 된다.

## 콜백 (Callback)

1. 다른 함수의 인자로써 이용되는 함수.
2. 어떤 이벤트에 의해 호출되어지는 함수.

*콜백은 다른 함수의 인수로 넘기는 함수*를 말하는데, 이 콜백을 가지고 비동기 프로그래밍을 할 수 있습니다.

콜백을 인수로 받는 함수가 항상 비동기식으로 동작하는 것은 아닙니다. 위 예제의 map, forEach의 인수로 넘겨준 것 역시 콜백이지만, 이 때에는 콜백이 동기식으로 호출됩니다. 즉, 콜백의 실행이 끝날때까지 코드의 실행 흐름이 다음으로 넘어가지 않습니다.

콜백은 _JavaScript가 고차함수를 잘 지원한다는 특징_ 때문에 가장 많이 사용되는 비동기 프로그래밍 양식이었습니다. 하지만 *콜백만으로는 복잡한 비동기 데이터 흐름를 표현하기가 어려워서 많은 프로그래머들이 힘들어했고, 결국 콜백 지옥(callback hell)*이라는 용어까지 생겨났습니다.

```js
// 비동기 콜백
function findUserAndCallBack(id, timeout, cb) {
	const user = {
		id: id,
		name: 'User' + id,
		email: id + '@test.com',
	};
	console.log();
	console.log(`waiting ${timeout}`);

	setTimeout(function () {
		cb(user);
	}, timeout);
}

findUserAndCallBack(1, 1000, function (user) {
	console.log('user:', user);
	findUserAndCallBack(2, 2000, function (user) {
		console.log('user:', user);
	});
});

// waiting 1000ms
// user: { id: 1, name: 'User1', email: '1@test.com' }

// waiting 2000ms
// user: { id: 2, name: 'User2', email: '2@test.com' }
```

## Promise

Promise는 *언젠가 끝나는 작업'의 결과값을 담는 통*과 같은 *객체*입니다. Promise 객체가 만들어지는 시점에는 그 통 안에 무엇이 들어갈지 모를 수도 있습니다. 대신 then 메소드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과값을 가지고 추가 작업을 할 수 있습니다.

Promise의 진가는, 복잡한 비동기 데이터 흐름을 다룰 때 발휘됩니다.

별로 중요해보이지 않는 아래의 두 특징을 활용하면, 콜백만 사용했을 때보다 코드를 훨씬 더 깔끔하게 작성할 수 있습니다.

- then 메소드는 Promise 객체를 반환하므로, 콜백을 중첩하지 않고도 비동기 작업을 연이어 할 수 있습니다.
- 비동기 작업이라는 동작 자체를 값으로 다룰 수 있게 됩니다. 즉, 이제까지 값을 다루면서 해왔던 모든 작업을 Promise 객체에 대해서도 할 수 있습니다.

## 비동기 함수 (Async Function)

ES2017에서 도입된 비동기 함수(async function)를 사용하면, 동기식 코드와 거의 같은 구조를 갖는 비동기식 코드를 짤 수 있습니다.

함수 앞에 _async_ 키워드를 붙이면, 이 함수는 비동기 함수가 됩니다.

비동기 함수는 *항상 Promise 객체를 반환한다는 특징*을 갖습니다. 이 Promise의 결과값은 비동기 함수 내에서 무엇을 반환하느냐에 따라 결정되며, then 메소드와 똑같은 방식으로 동작합니다.

또 하나의 중요한 특징은 비동기 함수 내에서 _await_ 키워드를 쓸 수 있다는 것입니다. _await는 Promise의 then 메소드와 유사한 기능을 하는데, await 키워드 뒤에 오는 Promise가 결과값을 가질 때까지 비동기 함수의 실행을 중단시킵니다_. 여기서의 '중단'은 비동기식이며, 브라우저는 Promise가 완료될 때까지 다른 작업을 처리할 수 있습니다.

await는 *연산자*이기도 하며, await 연산의 결과값은 뒤에 오는 Promise 객체의 결과값이 됩니다.

**비동기 함수의 가장 큰 장점은 동기식 코드를 짜듯이 비동기식 코드를 짤 수 있다는 것입니다.**

await 키워드는 _for, if와 같은 제어 구문 안에서도 쓰일 수 있기 때문에_, then 메소드를 사용할 때보다 복잡한 비동기 데이터 흐름을 아주 쉽게 표현할 수 있다는 장점이있습니다. 다만, 비동기 함수 역시 Promise를 사용하기 때문에, 비동기 함수를 잘 쓰기 위해서는 여전히 Promise에 대해 잘 알고 있어야 합니다.

## Generator

Iterable 챕터에 다뤘던 generator 함수는 '함수를 잠시 멈춰둘 수 있다'는 특징을 갖고 있습니다. 이 특징으로 인해 generator가 비동기 프로그래밍을 위해 사용되기도 합니다.

비동기 함수를 사용한 예제와 비교해서 보면, 코드의 구조가 굉장히 비슷합니다. _실제로, ES2017에서 비동기 함수가 도입되기 전에는 generator가 비동기 프로그래밍을 위해 널리 사용되었습니다_. 최근에는 언어에 내장되어 있고 더 쉬운 비동기 함수를 많이 사용하는 편입니다.

다만 generator는 *함수의 재개를 프로그래머가 직접 제어할 수 있다는 장점*을 갖고 있기 때문에, 일부러 비동기 함수 대신 generator를 사용하는 경우도 있습니다. React에서 비동기 프로그래밍을 하기 위해 널리 사용되는 라이브러리인 redux-saga 역시 generator를 활용하고 있습니다.

##

<!-- PoiemaWeb  -->

비동기식 처리 모델(Asynchronous processing model 또는 Non-Blocking processing model)은 병렬적으로 태스크를 수행한다. 즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다. 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 태스크를 수행할 때, 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 태스크를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 데이터를 가지고 수행할 태스크를 계속해 수행한다.

자바스크립트의 대부분의 DOM 이벤트 핸들러와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다.
